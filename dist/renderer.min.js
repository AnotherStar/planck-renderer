class Renderer{constructor(t,e,i={}){const s={scale:16,fps:60,speed:1,lineWidth:1/16,strokeStyle:{dynamic:"black",static:"black",kinematic:"black"}};this.options=Object.assign(s,i),i.lineWidth||(this.options.lineWidth=1/this.options.scale),this.world=t,this.ctx=e,this.canvas=e.canvas,this.update=null,this.draw=null,this.clear=((t,e)=>{e.clearRect(0,0,t.width,t.height)})}startUpdate(){const t=1/this.options.fps,e=1/this.options.speed*t;let i,s,o,n=performance.now(),r=0;const a=()=>{for(i=performance.now(),r+=Math.min(1,(i-n)/1e3);r>e;)this.world.step(t),"function"==typeof this.update&&this.update(t),r-=e;o=1/(s=(i-n)/1e3),n=i,this.renderWorld(o),requestAnimationFrame(a)};requestAnimationFrame(a)}renderWorld(t){const{ctx:e,options:i}=this;this.clear(this.canvas,e),"function"==typeof this.draw&&this.draw(e,t);for(let t=this.world.getBodyList();t;t=t.getNext())for(let s=t.getFixtureList();s;s=s.getNext()){if(t.render&&t.render.hidden)continue;t.render&&t.render.stroke?e.strokeStyle=t.render.stroke:t.isDynamic()?e.strokeStyle=i.strokeStyle.dynamic:t.isKinematic()?e.strokeStyle=i.strokeStyle.kinematic:t.isStatic()&&(e.strokeStyle=i.strokeStyle.static);const o=s.getType(),n=s.getShape();e.save(),e.scale(this.options.scale,this.options.scale),e.lineWidth=i.lineWidth,"circle"===o&&this.drawCircle(t,n),"edge"===o&&this.drawEdge(t,n),"polygon"===o&&this.drawPolygon(t,n),"chain"===o&&this.drawPolygon(t,n),e.restore()}for(let t=this.world.getJointList();t;t=t.getNext())e.save(),e.scale(this.options.scale,this.options.scale),this.drawJoint(t),e.restore()}drawCircle(t,e){const i=this.ctx,s=this.options.lineWidth,o=e.m_radius,n=t.getPosition(),r=t.getAngle(),a=2*o+2*s;if(i.translate(n.x+s,n.y+s),i.rotate(r),t.render&&t.render.custom){const e={x:-o-2*s,y:-o-2*s};if(!0!==t.render.custom(i,e,a+s))return}i.beginPath(),i.arc(0,0,o,0,2*Math.PI),i.stroke(),i.restore()}drawEdge(t,e){const i=this.ctx,s=this.options.lineWidth,o=e.m_vertex1,n=e.m_vertex2,r=n.x-o.x,a=n.y-o.y,h=Math.sqrt(r*r+a*a);i.translate(o.x+s,o.y+s),i.beginPath(),i.moveTo(s,s),i.lineTo(s+h,s),i.lineCap="round",i.stroke()}drawPolygon(t,e){const i=this.ctx,s=this.options.lineWidth,o=e.m_vertices;if(!o.length)return;let n=1/0,r=1/0,a=-1/0,h=-1/0;for(const t of o)n=Math.min(n,t.x),a=Math.max(a,t.x),r=Math.min(r,t.y),h=Math.max(h,t.y);const c=a-n,l=h-r,d=t.getPosition(),g=t.getAngle();if(i.translate(d.x+2*s,d.y+2*s),i.rotate(g),t.render&&t.render.custom){const e={width:c+s,height:l+s},o={x:n-s,y:r-s};if(!0!==t.render.custom(i,o,e))return}i.beginPath();for(let t=0;t<o.length;++t){const e=o[t],n=e.x-s,r=e.y-s;0===t?i.moveTo(n,r):i.lineTo(n,r)}o.length>2&&i.closePath(),i.stroke()}drawJoint(t){const e=this.ctx,i=t.getAnchorA(),s=t.getAnchorB();e.beginPath(),e.moveTo(i.x,i.y),e.lineTo(s.x,s.y),e.stroke()}}export default Renderer;