class Renderer{constructor(e,t,s={}){this.options=Object.assign({scale:1,fps:60,speed:1},s),this.world=e,this.ctx=t,this.canvas=t.canvas,this.clear=((e,t)=>{t.clearRect(0,0,e.width,e.height)})}startUpdate(){const e=1/this.options.fps,t=1/this.options.speed*e;let s,o=performance.now(),r=0;const a=()=>{for(s=performance.now(),r+=Math.min(1,(s-o)/1e3);r>t;)this.world.step(e),r-=t;o=s,this.renderWorld(),requestAnimationFrame(a)};requestAnimationFrame(a)}renderWorld(){this.clear(this.canvas,this.ctx);for(let e=this.world.getBodyList();e;e=e.getNext())for(let t=e.getFixtureList();t;t=t.getNext()){const s=t.getType(),o=t.getShape();"circle"===s&&(t.drawn=this.drawCircle(e,o)),"edge"===s&&(t.drawn=this.drawEdge(e,o)),"polygon"===s&&(t.drawn=this.drawPolygon(e,o))}}drawCircle(e,t){const s=this.options,o=this.ctx,r=t.m_radius,a=e.getPosition(),i=e.getAngle();o.save(),o.translate(a.x*s.scale,a.y*s.scale),o.rotate(i),o.beginPath(),o.arc(0,0,r*s.scale,0,2*Math.PI),o.stroke(),o.restore()}drawEdge(e,t){const s=this.options,o=this.ctx,r=t.m_vertex1,a=t.m_vertex2;o.beginPath(),o.moveTo(r.x*s.scale,r.y*s.scale),o.lineTo(a.x*s.scale,a.y*s.scale),o.stroke()}drawPolygon(e,t){const s=this.options,o=this.ctx,r=t.m_vertices,a=e.getPosition(),i=e.getAngle();if(r.length){o.save(),o.translate(a.x*s.scale,a.y*s.scale),o.rotate(i),o.beginPath();for(let e=0;e<r.length;++e){const t=r[e],a=t.x,i=t.y;0===e?o.moveTo(a*s.scale,i*s.scale):o.lineTo(a*s.scale,i*s.scale)}r.length>2&&o.closePath(),o.stroke(),o.restore()}}}export default Renderer;